(self.webpackChunkdurandal_starterkit=self.webpackChunkdurandal_starterkit||[]).push([["components-viewmodel"],{8785:(n,e,t)=>{"use strict";t.r(e),t.d(e,{default:()=>p}),t(5735),t(8188),t(3439),t(8673),t(6886);var a=t(584),r=t.n(a);t.e("child").then(t.bind(t,5612));const p=new function(){var n=this;this.view='<section>\n    <h1>Knockout components</h1>\n    <p>\n        Here are 3 nested components. Grandparent -> Parent -> Child. If you open up your network tab (and turn on\n        throttling to make it a bit clearer) when you load this page you will see:\n    </p>\n    <ol>\n        <li>The pages ViewModel load</li>\n        <li>\n            The child component load (with a descriptive name) and the grandparent component load at about the same time\n        </li>\n        <li>The parent component load</li>\n    </ol>\n    <p>\n        This is a showcase of how the application has control of when to lazy-load modules (including components which\n        are "loaded asynchronously")\n    </p>\n    <h2>Inputs</h2>\n    <p>Grandparent name: <input data-bind="value: $root.grandparentInput"></p>\n    <p>Parent name: <input data-bind="value: $root.parentInput"></p>\n    <p>Child name: <input data-bind="value: childInput"></p>\n\n    <h2>Grand parent (two nested components)</h2>\n    <grandparent params="grandparentValue: grandparentDisplay, \n                parentValue: parentDisplay,\n                childValue: childDisplay"></grandparent>\n</section>\n',this.modelName="ComponentViewModel",this.grandparentInput=r().observable("Grandparent Name").extend({required:!0}),this.parentInput=r().observable("Parent Name").extend({required:!0}),this.childInput=r().observable("Child Name").extend({required:!0}),this.grandparentDisplay=r().pureComputed((function(){return n.grandparentInput()}),this),this.parentDisplay=r().pureComputed((function(){return n.parentInput()}),this),this.childDisplay=r().pureComputed((function(){return n.childInput()}),this)}}}]);