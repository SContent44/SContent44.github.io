(window.webpackJsonp=window.webpackJsonp||[]).push([["components-viewmodel"],{193:function(n,e,a){"use strict";a.r(e);a(16),a(43);var t=a(1),r=a.n(t);a.e("child").then(a.bind(null,181));var p=new function(){var n=this;this.view='<section>\r\n    <h1>Knockout components</h1>\r\n    <p>\r\n        Here are 3 nested components. Grandparent -> Parent -> Child. If you open up your network tab (and turn on\r\n        throttling to make it a bit clearer) when you load this page you will see:\r\n    </p>\r\n    <ol>\r\n        <li>The pages ViewModel load</li>\r\n        <li>\r\n            The child component load (with a descriptive name) and the grandparent component load at about the same time\r\n        </li>\r\n        <li>The parent component load</li>\r\n    </ol>\r\n    <p>\r\n        This is a showcase of how the application has control of when to lazy-load modules (including components which\r\n        are "loaded asynchronously")\r\n    </p>\r\n    <h2>Inputs</h2>\r\n    <p>Grandparent name: <input data-bind="value: $root.grandparentInput"></p>\r\n    <p>Parent name: <input data-bind="value: $root.parentInput"></p>\r\n    <p>Child name: <input data-bind="value: childInput"></p>\r\n\r\n    <h2>Grand parent (two nested components)</h2>\r\n    <grandparent params="grandparentValue: grandparentDisplay, \r\n                parentValue: parentDisplay,\r\n                childValue: childDisplay"></grandparent>\r\n</section>\r\n',this.moduleName="ComponentViewModel",this.grandparentInput=r.a.observable("Grandparent Name").extend({required:!0}),this.parentInput=r.a.observable("Parent Name").extend({required:!0}),this.childInput=r.a.observable("Child Name").extend({required:!0}),this.grandparentDisplay=r.a.pureComputed((function(){return n.grandparentInput()}),this),this.parentDisplay=r.a.pureComputed((function(){return n.parentInput()}),this),this.childDisplay=r.a.pureComputed((function(){return n.childInput()}),this)};e.default=p}}]);